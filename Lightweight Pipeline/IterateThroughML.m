
%% Iterate Through ML
% This script iterates through the ML methods specified in dashboard.m
% using the data generated by HHDataStructure.m --> prepareForML.m

                                                                            % Project: USC RAM
                                                                            % Author: Garrett Flynn and Xiwei She
                                                                            % Date: July 26th, 2019

if exist('dataML', 'var')

 % Choose ML Methods
 kMeans = ~isempty(cell2mat(regexpi(mlAlgorithms,{'kMeans'})));
 supervisedMethods = zeros(1,length(mlAlgorithms));
 for algIter = 1:length(mlAlgorithms)
     match = cell2mat(regexpi(mlAlgorithms{algIter},{'lassoGLM','naiveBayes','SVM','linear','kernel','knn','tree','RUSBoost'}));
     if ~isempty(match)
 supervisedMethods(algIter) =  match;
     end
     end
 supervisedMethods = (sum(supervisedMethods)) > 0;
 imageMethods = ~isempty(cell2mat(regexpi(mlAlgorithms,{'CNN_SVM'})));
 
 
 % Initialize Save Directories and Other Parameters
        if supervisedMethods
            resultsDir = fullfile(parameters.Directories.filePath,['Classifier Results [-',num2str(range),' ',num2str(range),']']);
            collectMCC = [];
        end
        
        if kMeans
            kResultsDir =  fullfile(parameters.Directories.filePath,['kMeans Results [-',num2str(range),' ',num2str(range),']']);
            saveBars = fullfile(parameters.Directories.filePath,'MCC Bar Plots');
            
            realClust = realClusters(dataML.Labels);
            savePCAViz = fullfile(parameters.Directories.filePath,'PCA Scatter Plots');
        end
        
        count = 1;
        
        channelStandard = dataML.Channels.sChannels;
        
for chosenFormat = 1:length(dataFormat)
    format = dataFormat{chosenFormat};
    currentData = dataML.(format);
if ndims(currentData) == 4
%% Method One: Unfold Time & Frequency Components into Vectors (or leave as is)
        temp = permute(currentData,[4,3,2,1]);
        dataPermute = temp(:,:,:);
        featureMatrix.Data.dataPermute =  permute(dataPermute,[1,3,2]);
        [t,d,c] = size(dataPermute);
        clear temp
        
        % Use the following code to reverse a given trial/electrode
        %reshaped = reshape(dataML.Data(1,1,:),size(temp,3),size(temp,4))';
        
%% Method Two: Compress Each Interval-Channel Combination into its First PC
pcaParsed = zeros(size(currentData, 2), size(currentData, 3), size(currentData, 4));
        for channel = 1:size(currentData, 3)
            for trial = 1:size(currentData, 4)
                tempFreqTime = currentData(:, :, channel, trial);
                [~, scoreTemp, ~] = pca(tempFreqTime');
                pcaParsed(:, channel, trial) = scoreTemp(:, 1); % Only pick the first PC due to the dimension limit
            end
        end
        
       featureMatrix.Data.pcaParsed = permute(pcaParsed, [3, 1, 2]); % Set the dimension order as Trial * Time(Feature) * Neuron for the B-Spline input
       clear tempFreqTime
       clear scoreTemp
       
elseif ndims(currentData) == 3     
%% Method Three: Signals Only
featureMatrix.Data.(format) = dataML.(format);

% Visualization of Signal Data
    % if ndims(dataML.Data) == 3
    %     TrialChannelData_Visualization(dataML.Data,dataML.Labels,{channelStandard,iCA1,dataML.Channels.CA3_Channels},fullfile(parameters.Directories.filePath,'Region Signal Responses',chosenFormat)
    % end
end

%% Begin Iterations
 % Populate Feature Matrix with Other DataML Info      
                   featureMatrix.Channels = dataML.Channels;
                   featureMatrix.Directory = dataML.Directory;
                   featureMatrix.Labels = dataML.Labels;
                   featureMatrix.WrongResponse = dataML.WrongResponse;
                   featureMatrix.Times = dataML.Times;
    
            for method = 1:length(mlScope)
                name = mlScope{method};
                
                %% Switch Between MCA, CA1, and CA3 Methods
                    fprintf(['\n',name,'\n']);
                    switch name
                        case 'MCA'
                    channelChoices = dataML.Channels.sChannels;
                        case 'CA1'
                    channelChoices = dataML.Channels.CA1_Channels;
                        case 'CA3'
                    channelChoices = dataML.Channels.CA3_Channels;      
                    end
                
                    
                resCount = 1;    
                for resolutions_to_retain = resChoice
                    coeffIter = 1;
                    coeffCount = 1;
                     for coeffRanks_to_retain = coeffIter
                           retained = [];
                           retainCache = length(channelChoices)-1; % Amount of PCA Components Available
                        
                   
%                    %% Original Features: Concatenated Channel Features
%                    % Run when PCA is active OR when Bspline is not active
%                     if  ~bspline
%                         if ~strcmp(feature,'PCA')
%                     featureMatrix.Data  = zeros(t, d*length(channelChoices));
%                     channelIndices = find(ismember(channelStandard,channelChoices));
%                     for channels = 1:length(channelChoices)
%                         featureMatrix.Data(:,((channels-1)*d)+1:(channels)*d) =  squeeze(dataML.Data(:,:,channelIndices(channels)));
%                     end
%                     indVar = 'PCA Coefficients (per channel)';
%                         end
%                     end
                   %% PCA Features 
%                 if strcmp(feature,'PCA')
%                     channelScore = zeros(t,length(channelChoices),length(channelChoices)-1);
%                 for trials = 1:t
%                     temp = squeeze(featureMatrix.Data(trials,:,:));
%                     [~,channelScore(trials,:,:)] = pca(temp');
%                 end
%                     clear temp
% 
%                     toPermute = channelScore(:,:,1:coeffRanks_to_retain);
%                         rPCA = permute(toPermute,[1,3,2]);
%                     
%                    featureMatrix.Data = rPCA;
%                     end
                   %% BSpline Features
                    if bspline
                        
                         % Permute (concatenate) data
                            BSplineInput1 = featureMatrix.Data.dataPermute;
                            MCA_BSFeatures_Permute = InputTensor2BSplineFeatureMatrix(BSplineInput1,resolutions_to_retain,BSOrder);
                            featureMatrix.Data.dataPermute = MCA_BSFeatures_Permute;
                            clear MCA_BSFeatures_Permute
                            
                            % PCA parsed data
                            BSplineInput2 = featureMatrix.Data.pcaParsed;
                            MCA_BSFeatures_PCA = InputTensor2BSplineFeatureMatrix(BSplineInput2,resolutions_to_retain,BSOrder);
                            featureMatrix.Data.pcaParsed = MCA_BSFeatures_PCA;
                            clear MCA_BSFeatures_PCA
                            
                            % Permute (concatenate) data
                            BSplineInput3 = featureMatrix.Data.Signal;
                            BSplineInput3 = permute(squeeze(BSplineInput3), [3, 1, 2]);
                            MCA_BSFeatures_Signal = InputTensor2BSplineFeatureMatrix(BSplineInput3,resolutions_to_retain,BSOrder);
                            featureMatrix.Data.Signal = MCA_BSFeatures_Signal;
                            clear MCA_BSFeatures_Signal
                            
                            indVar = 'BSpline Resolution';

                        
                    end

                    
                    %% Classification Section
                    
                    % Run K-Means
                    if kMeans
                        quickSNE
                        [kResults.(name).(featureCounter).clusterIndices] = kMeansClustering(featureMatrix,name);
                        saveBarsFull = fullfile(saveBars,name,featureCounter);
                        [kResults.(name).(featureCounter).MCC,kResults.(name).(featureCounter).MCC_Categories,~,~] = parseClusterAssignments(featureMatrix,kResults.(name).(featureCounter).clusterIndices, name,{featureMatrix.Labels,retained,name,norm(iter),saveBarsFull});
                        count = count + 1;
                    end
                    
                  % Run Supervised Classifiers
                    if supervisedMethods
                        [collectMCC,learners, categories,features] = trainClassifiers(featureMatrix,mlAlgorithms,feature,collectMCC,coeffCount,resCount);
                    
                    end
                    
                    coeffCount = coeffCount + 1;
                     end
                     
                    resCount =resCount + 1;
                end
                if supervisedMethods
                cResults.(name) = collectMCC;
                cResults.MetaData.usedLearners = learners;
                cResults.MetaData.usedCategories = categories;
                cResults.MetaData.caseNames = features;
                cResults.MetaData.Resolutions = resChoice;
                cResults.MetaData.pcaCoefficients = retainCache;
                saveNameTemp = dataFormat(chosenFormat);
                
                if ~exist(resultsDir,'dir')
                mkdir(resultsDir);
                end

                save(fullfile(resultsDir,['singleTestResult_', saveNameTemp{1},'.mat']), 'cResults', '-v7.3');
                %plotMCCvsFeatures(cResults.(name),resChoice,norm(iter),resultsDir,[name,' ',feature],indVar);
                end
            end
            
            %% Organize Results
            if kMeans 
                %kSave
            end
            if supervisedMethods
                %classSave;
                %visualizeClassifierPerformance(cResults,norm(iter),fullfile(resultsDir,['MCCs for ',feature]));
            end
    clear cResults
    clear kResults
            
end
end

%% PCA 2D/3D Visualizations

%[kResults.(name).(featureCounter).MCC,kResults.(name).(featureCounter).MCC_Categories,collectedClusterings(:,count),excluded{count}] = parseClusterAssignments(featureMatrix,kResults.(name).(featureCounter).clusterIndices, name,{featureMatrix.Labels,retained,name,norm(iter),saveBarsFull});
%                             if coeffRanks_to_retain ==  2
%                                 PCA2CountMCA = count;
%                             elseif coeffRanks_to_retain ==  3
%                                 for len = 1:size(collectedClusterings,1)
%                                     orderedClustersMCA_PCA = [collectedClusterings(len,PCA2CountMCA) , collectedClusterings(len,count)];
%                                     excludedMCA_PCA = {excluded{PCA2CountMCA} , excluded{count}};
%                                     label = 'All Above';
%                                     createPCAVisualizations(scoreMCA,orderedClustersMCA_PCA,['MCA ' ,label,' ', num2str(nIters-(len-1))],norm(iter),fullfile(savePCAViz,['MCA_' label]),excludedMCA_PCA);
%                                     createPCAVisualizations_RealClusters(scoreMCA,realClust,'MCA Correct Cluster',norm(iter),fullfile(savePCAViz,['CorrectMCA_' label]),fieldnames(dataML.Labels));
%                                     
%                                 end
%                             end
%                             count = count + 1;
            
            
    
    
%% CNN For Feature Selection (on hiatus)
%     if CNN_SVM
%         CNN_Pipeline;
%         processAllClassestoResults(results,'CNN_SVM');
%         supervisedDir = fullfile(parameters.Directories.filePath,'CNN Results');
%         
%         if ~exist(supervisedDir,'dir')
%             mkdir(supervisedDir);
%         end
%         if norm(iter) == 1
%             save(fullfile(supervisedDir,[parameters.Directories.dataName, 'ResultsNorm.mat']),'results');
%         else
%             save(fullfile(supervisedDir,[parameters.Directories.dataName, 'Results.mat']),'results');
%         end
%     end