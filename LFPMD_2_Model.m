
%% Iterate Through ML
% This script iterates through the ML methods specified in dashboard.m
% using the data generated by HHDataStructure.m --> prepareForML.m

                                                                            % Project: USC RAM
                                                                            % Author: Garrett Flynn and Xiwei She
                                                                            % Date: July 26th, 2019

if exist('dataML', 'var')

 % Choose ML Methods
 kMeans = ~isempty(cell2mat(regexpi(mlAlgorithms,{'kMeans'})));
 if kMeans 
     
 warning('kMeans is not supported for new featureset. Please recode this section if you wish to conduct unsupervised classification.');    
 
 end
 
 supervisedMethods = zeros(1,length(mlAlgorithms));
 for algIter = 1:length(mlAlgorithms)
     match = cell2mat(regexpi(mlAlgorithms{algIter},{'lassoGLM','naiveBayes','SVM','linear','kernel','knn','tree','RUSBoost'}));
     if ~isempty(match)
 supervisedMethods(algIter) =  match;
     end
end
 supervisedMethods = (sum(supervisedMethods)) > 0;
 imageMethods = ~isempty(cell2mat(regexpi(mlAlgorithms,{'CNN_SVM'})));
 
 
 % Initialize Save Directories and Other Parameters
        if supervisedMethods
            resultsDir = fullfile(parameters.Directories.filePath,['Classifier Results [-',num2str(range),' ',num2str(range),']']);
            collectMCC = [];
        end
        
        count = 1;
        
        channelStandard = dataML.Channels.sChannels;
        
for chosenFormat = 1:length(dataFormat)
    format = dataFormat{chosenFormat};
    currentData = dataML.(format);
        [f,t,c,tr] = size(currentData);
    d = f*t;
  
    if ~isempty(regexpi(format,'Signal'))
    typeIn = 'Signal';
    elseif ~isempty(regexpi(format,'Spectrum'))
        typeIn = 'Spectrum';
    else
        error('Input not supported');
    end
    
%% PCA Channel Reduction
if parameters.Choices.reduceChannels   
channelPCA = zeros(f, t, 2,tr);

numPreviousSaved = 0;
for CA1vsCA3 = 1:2
    if CA1vsCA3 == 1
        currentChans = dataML.Channels.CA1_Channels;
    elseif CA1vsCA3 == 2
        currentChans = dataML.Channels.CA3_Channels;
    end
    disc = sum(diff(currentChans)>1)+1; % Find the number of channel clusters
    cSave = 1:disc; % Pull out that many components from PCA
    
     if CA1vsCA3 == 1
         cChoice = find(ismember(channelStandard,dataML.Channels.CA1_Channels));
     elseif CA1vsCA3 == 2
     cChoice = find(ismember(channelStandard,dataML.Channels.CA3_Channels));
     end
     
for trial = 1:tr
    for freq = 1:f
           tempTimeChannel = squeeze(currentData(freq,:,cChoice,trial));
           [~, scoreTemp, ~,~,explained(:,trial*freq),~] = pca(tempTimeChannel);
           channelPCA(freq,:,numPreviousSaved+cSave,trial) = scoreTemp(:, cSave); % Only pick the first 3 PCs due to channel spacing   
    end
end

numPreviousSaved = numPreviousSaved + length(cSave);
% figure;
% histogram(explained(1,:))
clear explained
clear scoreTemp
clear tempTimeChannel
end 
currentData = channelPCA;
    [f,t,c,tr] = size(currentData);
    d = f*t;
clear channelPCA
    
end
    
    
signalOn = 0; % Assume Signal is Off   
if strcmp(typeIn,'Spectrum')
%% Method One: Unfold Time & Frequency Components into Vectors (or leave as is)
        temp = permute(currentData,[4,3,2,1]);
        dataPermute = temp(:,:,:);
        featureMatrix.dataPermute.(format) =  permute(dataPermute,[1,3,2]);
        clear temp
        
        % Use the following code to reverse a given trial/electrode
        %reshaped = reshape(dataML.Data(1,1,:),size(temp,3),size(temp,4))';
        
%% Method Two: Compress Each Interval-Channel Combination into its First PC
pcaParsed = zeros(size(currentData, 2), size(currentData, 3), size(currentData, 4));
        for channel = 1:c
            for trial = 1:tr
                tempFreqTime = currentData(:, :, channel, trial);
                [~, scoreTemp, ~] = pca(tempFreqTime');
                pcaParsed(:, channel, trial) = scoreTemp(:, 1); % Only pick the first PC due to the dimension limit
            end
        end
       
       featureMatrix.pcaParsed.(format) = permute(pcaParsed, [3, 1, 2]); % Set the dimension order as Trial * Time(Feature) * Neuron for the B-Spline input
       
       clear tempFreqTime
       clear scoreTemp
       
elseif strcmp(typeIn,'Signal')    
%% Method Four: Signals Only
featureMatrix.Signals.(format) = dataML.(format);

signalOn = 1;

% Visualization of Signal Data
    % if ndims(dataML.Data) == 3
    %     TrialChannelData_Visualization(dataML.Data,dataML.Labels,{channelStandard,iCA1,dataML.Channels.CA3_Channels},fullfile(parameters.Directories.filePath,'Region Signal Responses',chosenFormat)
    % end
    
    
    
end
end

%% Begin Iterations
 % Populate Feature Matrix with Other DataML Info      
                   featureMatrix.Channels = dataML.Channels;
                   featureMatrix.Directory = dataML.Directory;
                   featureMatrix.Labels = dataML.Labels;
                   featureMatrix.WrongResponse = dataML.WrongResponse;
                   featureMatrix.Times = dataML.Times;
    
            for method = 1:length(mlScope)
                name = mlScope{method};
                
                %% Switch Between MCA, CA1, and CA3 Methods
                    fprintf(['\n',name,'\n']);
                    switch name
                        case 'MCA'
                    channelChoices = dataML.Channels.sChannels;
                        case 'CA1'
                    channelChoices = dataML.Channels.CA1_Channels;
                        case 'CA3'
                    channelChoices = dataML.Channels.CA3_Channels;      
                    end
                
                    
                resCount = 1;    
                for resolutions_to_retain = resChoice
                    coeffIter = 1;
                    coeffCount = 1;
                     for coeffRanks_to_retain = coeffIter
                           retained = [];
                           retainCache = length(channelChoices)-1; % Amount of PCA Components Available
                   %% BSpline Features
                    if bspline
                        
                        specFields = fieldnames(featureMatrix.pcaParsed); % Check fields in pcaParsed as a proxy for all spectral featuresets
                        
                        for specIter = 1:length(specFields)
                            
                         % Permute (concatenate) data
                         saveCase = [specFields{specIter},'_dataPermute'];
                            BSplineInput1 = featureMatrix.dataPermute.(specFields{specIter});
                            MCA_BSFeatures_Permute = InputTensor2BSplineFeatureMatrix(BSplineInput1,resolutions_to_retain,BSOrder);
                            featureMatrix.Data.(saveCase) = MCA_BSFeatures_Permute;
                            clear MCA_BSFeatures_Permute
                            
                            % PCA parsed data
                            saveCase = [specFields{specIter},'_pcaParsed'];
                            BSplineInput2 = featureMatrix.pcaParsed.(specFields{specIter});
                            MCA_BSFeatures_PCA = InputTensor2BSplineFeatureMatrix(BSplineInput2,resolutions_to_retain,BSOrder);
                            featureMatrix.Data.(saveCase) = MCA_BSFeatures_PCA;
                            clear MCA_BSFeatures_PCA
                        end   
                            % Bspline on Pure Signals
                            if signalOn
                                sigFields = fieldnames(featureMatrix.Signals);
                                
                                for sigIter = 1:length(sigFields)
                            BSplineInput3 = featureMatrix.Signals.(sigFields{sigIter});
                            BSplineInput3 = permute(squeeze(BSplineInput3), [3, 1, 2]);
                            MCA_BSFeatures_Signal = InputTensor2BSplineFeatureMatrix(BSplineInput3,resolutions_to_retain,BSOrder);
                            featureMatrix.Data.(sigFields{sigIter}) = MCA_BSFeatures_Signal;
                            clear MCA_BSFeatures_Signal
                                end
                            end
                            
                            indVar = 'BSpline Resolution';

                        
                    end

                    
                    %% Classification Section
                    if supervisedMethods
                        [collectMCC,learners, categories,featureCases] = trainClassifiers(featureMatrix,mlAlgorithms,collectMCC,coeffCount,resCount);
                        cResults.(name) = collectMCC;
                        
                cResults.MetaData.usedLearners = learners;
                cResults.MetaData.usedCategories = categories;
                cResults.MetaData.caseNames = featureCases;
                cResults.MetaData.Resolutions = resChoice;
                cResults.MetaData.pcaCoefficients = retainCache;
                saveNameTemp = dataFormat(chosenFormat);
                
                if ~exist(resultsDir,'dir')
                mkdir(resultsDir);
                end
                 delete(fullfile(resultsDir,'singleTestResult_*.mat')); 
                save(fullfile(resultsDir,['singleTestResult_',datestr(now,'mm-dd-yyyy HH-MM'),'.mat']), 'cResults', '-v7.3');
                end
                    
                    coeffCount = coeffCount + 1;
                     end
                     
                    resCount =resCount + 1;
                end
            end
            
    clear cResults
    clear kResults
            
end

%% Bspline Utilities
function b = bspline(dp, i, L)% dp- order, i- knots, L- length
t = linspace(0,1,L+1); % range of data
t = t(2:end);

s = linspace(0,1,i);% knot sequence
nknots = length(s); % number of knots

knots=augknt(s,dp); % knot points
colmat=spcol(knots,dp,brk2knt(t,3));
b=colmat(1:3:end,:); % B-spline basis functions
end

function P = InputTensor2BSplineFeatureMatrix(inputTensor,m,d)
% Convert input tensor to B-spline feature matrix
% inputTensor: # of trials * time interval window * # of neurons
% m: # of B-Spline knots, resolution
% d: B-Spline order, default 2 or 3
% Author: Xiwei She

% Get tensor dimension
[NP,L,N] = size(inputTensor);

% Generate B-splines
b = bspline(d+1,m+2,L);
Nb = m+d+1;

P = zeros(NP,Nb*N);

for i = 1:NP
    PSpike = squeeze(inputTensor(i,:,:))';
    PSplineM = PSpike*b;
    PSplineV = reshape(PSplineM',Nb*N,1)';
    P(i,:) = PSplineV;
end
end

function b =spl(dp,i)% dp- order, i- knots
t = linspace(0,1,2001); % range of data
t = t(2:end);

s = linspace(0,1,i);% knot sequence
nknots = length(s); % number of knots

knots=augknt(s,dp); % knot points
colmat=spcol(knots,dp,brk2knt(t,3));
b=colmat(1:3:end,:); % B-spline basis functions
end

function P = Train2Tensor(X, E, L)
% X: spike trains with 2ms resolution
% E: event timings in sec
% L: number of bins in pattern tensor

[Len, N] = size(X);
NumTrial = length(E);

P = zeros(NumTrial,L+1,N); % spike tensor % NumTrial - # of trials(Sample_response); L+1 - Length of bin window; N - # of Channels(CA3+CA1)

for i = 1:NumTrial
    t = round(E(i)*500);
    tmin = t - L/2;
    tmax = t + L/2;
    a = X(tmin:tmax,:);
    P(i,:,:) = a;
end
end


%% Supervised Classification Functions
function [collectMCC,usableAlgorithms,fieldLabels,caseNames] = trainClassifiers(featureMatrix,mlAlgorithms,collectMCC,pcaCoeff,bRes);
% This function uses supervised methods to classify LFP data

                                                                            % Project: USC RAM
                                                                            % Author: Garrett Flynn
                                                                            % Date: July 26th, 2019


close all;

wrong = featureMatrix.WrongResponse;

% Remove K-Means from Algorithm Choices
notK = find(~ismember(mlAlgorithms,'kMeans'));
sizeDiff = length(mlAlgorithms) - length(notK);
if sizeDiff > 0
    usableAlgorithms = cell(1,sizeDiff);
for ii = 1:length(notK)
usableAlgorithms{ii} = mlAlgorithms{notK(ii)};
end
else
    usableAlgorithms = mlAlgorithms;
end
    
caseNames = fieldnames(featureMatrix.Data);
numCases = length(caseNames);
for featureCase = 1:numCases 

currentCase = caseNames{featureCase};
currentData = featureMatrix.Data.(currentCase);

% Extract Correct Trials
allVec = 1:size(currentData,1);
matrixToProcess = currentData(allVec~=wrong,:);


%% Begin Label Loop
fields = fieldnames(featureMatrix.Labels);
fieldLabels = erase(fields,'Label_');
labels = cell(size(featureMatrix.Labels.(fields{1}),1),1);
numTrials = size(featureMatrix.Labels.(fields{1}),1);
labels = labelMaker(fields);

for learner = 1:length(usableAlgorithms)
    fprintf(['Learner: ',usableAlgorithms{learner},'\n']);
    for categoriesToTrain = 1:length(fieldLabels)
        fprintf(['\t',fields{categoriesToTrain},'\n']);
        labelCache = cell(numTrials,1);
        currentField = fieldLabels{categoriesToTrain};
        for qq = 1:numTrials
            if strfind(labels{qq},currentField)
                labelCache{qq} = currentField;
            else
                labelCache{qq} = ['~',currentField];
            end
        end
        
        labelCache = labelCache(allVec~=wrong);
        labelCacheCat = categorical(labelCache);
        clear classifier
        %% Custom Loss Function
        %         binaryLabels = ismember(labelCache,currentField);
        %               crossEntropy = @(~,S,~,~)mean(min(-S,[],2));
        
        %% Begin Model Testing
            if ~strcmpi(usableAlgorithms{learner},'LassoGLM')
                % Linear Lasso
                if strcmpi(usableAlgorithms{learner},'linear')
                    ourLinear = templateLinear('Learner','svm','Regularization','lasso');
                    classifier = fitcecoc(matrixToProcess', labelCacheCat, ...
                        'Learners', ourLinear,'ObservationsIn', 'columns','Kfold',10);
                    clear ourLinear
                    % KNN
                elseif strcmpi(usableAlgorithms{learner},'knn')
                    ourKNN = templateKNN('NSMethod','exhaustive','Distance','cosine');
                    classifier = fitcecoc(matrixToProcess', labelCacheCat, ...
                        'Learners', ourKNN,'ObservationsIn', 'columns','Kfold',10);
                    clear ourKNN
                    % RusBoost (unbalanced classes)
                elseif strcmpi(usableAlgorithms{learner},'RUSBoost')
                    N = ceil(length(labelCacheCat)/10);         % Number of observations in training samples
                    t = templateTree('MaxNumSplits',N);
                    classifier = fitcensemble(matrixToProcess,labelCacheCat,'Method',usableAlgorithms{learner}, ...
                        'NumLearningCycles',1000,'Learners',t,'LearnRate',0.1,'nprint',100,'KFold',10);
                    clear t
                else
                    % SVM, Trees, Kernel, or Bayes
                    classifier = fitcecoc(matrixToProcess', labelCacheCat, ...
                        'Learners', usableAlgorithms{learner},'ObservationsIn', 'columns','Kfold',10);
                end

                predictedLabels = kfoldPredict(classifier);
                testLabels =  labelCacheCat;
                
                % Confusion Matrix Results
                [confMat,~] = confusionmat(testLabels, predictedLabels);
                %conf = confusionchart(testLabels,predictedLabels);
                currentMCC  = ML_MCC(confMat);
                
                 disp([currentCase,'Case | Confusion matrix: ']);
                disp(confMat);
                disp([currentCase, 'Case | MCC = ', mat2str(currentMCC)]);
                
                % Lasso GLM
            else
                binaryLabels = ismember(labelCacheCat,currentField);
                [Coefficients, FitInfo] = lassoglm(matrixToProcess, binaryLabels, 'binomial','MaxIter',25,'CV', 10,'Lambda',power(10,0:-.1:-2));
                legend('show') % Show legend
                %lp = lassoPlot(Coefficients,FitInfo,'plottype','CV');
                
                % Predict
                indx = FitInfo.IndexMinDeviance;
                cnst = FitInfo.Intercept(indx);
                B0 = Coefficients(:,indx);
                B1 = [cnst;B0];
                predictions = glmval(B1,matrixToProcess,'logit');
                
                lassoPredictions = (predictions >= .5);
                predSize = length(predictions);
                realPredicts = cell(1,predSize);
                for ii = 1:predSize
                    if lassoPredictions(ii)
                        realPredicts{ii} = currentField;
                    else
                        realPredicts{ii} = ['~',currentField];
                    end
                end
                [confMat,~] = confusionmat(labelCache, realPredicts);
                currentMCC  = ML_MCC(confMat);
                
                 disp([currentCase,'Case | Confusion matrix: ']);
                disp(confMat);
                disp([currentCase, 'Case | MCC = ', mat2str(currentMCC)]);
                
                %conf = confusionchart(labelCache,realPredicts);
            end
%% Save MCC
% outMCCs STRUCTURE
%   1D = Learners;
%   2D = Labels;
%   3D = Input Feature Type;
%   4D = Current PCA Coefficient
%   5D = Current Bspline Resolution

            collectMCC(learner,categoriesToTrain,featureCase,pcaCoeff,bRes) = currentMCC;
        end

            
    end
end
end

function [labels] = labelMaker(fields)
fprintf('Making Labels\n');
%fields = fieldnames(dataML.Labels);
% fieldLabels = erase(fields,'Label_');
% labels = cell(size(dataML.Labels.(fields{1}),1),1);
% numTrials = size(dataML.Labels.(fields{1}),1);
for jj = 1:length(fields)
    currentField = featureMatrix.Labels.(fields{jj});
    for qq = 1:size(currentField,1)
        if currentField(qq) == 1
            if ~isempty(labels{qq})
                labels{qq} = [labels{qq} '_' fieldLabels{jj}] ;
            else
                labels{qq} = fieldLabels{jj};
            end
        end    
    end
end

for qq = 1:size(currentField,1)
if isempty(labels{qq});
    zero = qq;
    labels{zero} = 'None';
end
end
end

function [MCC] = ML_MCC(confMat)
% Determine MCCs from ML Confusion Matrix Outputs

topLeft = confMat(1,1);
bottomLeft = confMat(2,1);
topRight = confMat(1,2);
bottomRight = confMat(2,2);

true1 = topLeft;
true2 = bottomRight;
false1 = bottomLeft;
false2 = topRight;

denominator = sqrt((true1+false1)*(true1+false2)*(true2+false1)*(true2+false2));

if denominator ~= 0
MCC = ((true1*true2)-(false1*false2))/denominator;
else
MCC = 0;
end

end
   